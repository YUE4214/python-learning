###2025年8月1日学习笔记：
# 1.字典常见操作二
# 1.1 len()求长度
# villager = {"职业": "铁匠", "等级": 1}
# print("字典内容：", villager)
# print(len(villager))
# 1.2 keys():返回字典里面包含的所有键名
# villager = {"职业": "铁匠", "等级": 1}
# print(villager.keys())
# 可以使用for循环取出键名
# 1.3 values():返回字典里面包含的所有值
# villager = {"职业": "铁匠", "等级": 1}
# print(villager.values())
# 可以使用for循环取出值
# 1.4 items():返回字典里面包含的所有键值对，键值对以元组的形式
# villager = {"职业": "铁匠", "等级": 1}
# print(villager.items())
# 2.字典的应用场景
# 使用键值对存储描述一个物品的相关信息。
# 3.集合
# 3.1集合
# 格式：s1 = {元素1, 元素2, 元素3,,,,, }。元素可以是不同的类型。
# 区分空字典和空集合
# s1 = set() #定义空集合
# s1 = {} #定义空字典
# s1 = {"a", 2, 3, "yue", "无"}
# print(s1, type(s1))
# 3.2集合的无序性
# 主要跟hash值有关，每次运行结果不同，hash值不同，那么在hash表中位置不同，实现了集合的无序性
# int整型的hash值就是它本身，在hash表中的位置不发生改变，顺序也不会变。但是仅限整型。
# 无序性：也就不能修改集合中的值，因为没有下标这些属性
# s1 = {"a", 2, 3, "yue", "无"}
# print(s1) #每次输出结果不同
# s2 = {1, 2, 9, 3, 4, 5} #纯数字的输出结果相同
# print(s2)
# 3.3集合具有唯一性，可以自动去重
# s2 = {1, 2, 2, 2, 4, 5}
# print(s2) #输出{1, 2, 4, 5}
# 3.4集合的常见操作
# 添加元素add():添加的是一个整体，如果添加的元素已经存在，则不进行任何操作。一次只能添加一个元素或者可迭代对象。
# 添加元素update():把输入的元素一个个拆分，加入集合中，输入对象必须是可迭代对象。
# s1 = {"a", 2, 3, "yue", "无"}
# print(s1)
# s1.add("限")
# s1.update(["阶级",9,3])
# print(s1)
# 删除元素remove()：选择删除的元素，若删除的元素不存在，则会报错
# 删除元素pop()：默认删除根据hash表排序后的第一个元素
# 删除元素discard()：选择删除的元素，若删除的元素不存在，则不进行任何操作
# s1 = {2, 3, '阶级', 9, 'a', '限', 'yue', '无'}
# s1.remove(2)
# print(s1)
# s1.pop()
# print(s1)
# 3.5交集和并集
# 交集：& 如果集合不相交，则返回空集合set()
# 并集：|
# s1 = {2, 3, '阶级', 9, 'a', '限', 'yue', '无'}
# s2 = {2, 3, '级', 8, 'a', '限', 'd', '无'}
# print(s1 & s2)
# print(s1 | s2)

# 字典进阶操作与集合知识点总结（结合《我的世界》）


# 一、字典常见操作（续）
# 1. 求长度：len(字典名)
#   - 功能：返回字典中键值对的数量
#   - 示例：
#     villager = {"职业": "铁匠", "等级": 1}
#     print(len(villager))  # 输出2（包含2个键值对）

# 2. 获取所有键：字典名.keys()
#   - 功能：返回字典中所有键组成的可迭代对象（类似列表）
#   - 遍历方式：for 键 in 字典名.keys():
#   - 示例：
#     tools = {"木镐": 1, "石剑": 2}
#     print(tools.keys())  # 输出dict_keys(['木镐', '石剑'])
#     for key in tools.keys():
#         print(key)  # 依次输出'木镐'、'石剑'

# 3. 获取所有值：字典名.values()
#   - 功能：返回字典中所有值组成的可迭代对象
#   - 遍历方式：for 值 in 字典名.values():
#   - 示例：
#     blocks = {"草方块": 64, "石头": 32}
#     print(blocks.values())  # 输出dict_values([64, 32])
#     for value in blocks.values():
#         print(value)  # 依次输出64、32

# 4. 获取所有键值对：字典名.items()
#   - 功能：返回字典中所有键值对组成的可迭代对象，每个键值对以元组(键, 值)形式存在
#   - 遍历方式：for 键, 值 in 字典名.items():
#   - 示例：
#     mobs = {"僵尸": 5, "骷髅": 3}
#     print(mobs.items())  # 输出dict_items([('僵尸', 5), ('骷髅', 3)])
#     for k, v in mobs.items():
#         print(k, v)  # 依次输出'僵尸 5'、'骷髅 3'

# 5. 字典应用场景补充
#   - 存储复杂实体属性（如生物的生命值、攻击力、掉落物）
#   - 配置信息管理（如游戏难度、音效开关等设置）
#   - 映射关系存储（如物品ID与名称的对应：{1: "石头", 2: "草方块"}）


# 二、集合（set）
# 1. 基本定义与格式
#   - 格式：集合名 = {元素1, 元素2, ...}，元素类型可混合（数字、字符串等）
#   - 空集合定义：必须用set()（不能用{}，{}表示空字典）
#   - 示例：
#     ores = {"煤矿", "铁矿", "金矿"}  # 普通集合
#     empty_set = set()  # 空集合
#     not_empty_dict = {}  # 这是空字典，不是集合

# 2. 核心特性：无序性
#   - 定义：集合中元素没有固定顺序，每次打印顺序可能不同（与元素的hash值有关）
#   - 例外：纯整数集合的顺序固定（因为整数的hash值等于自身）
#   - 注意：无序性导致集合**不能通过下标访问元素**，也**不能修改元素**（只能增删）
#   - 示例：
#     mixed_set = {"木头", 3, "钻石"}
#     print(mixed_set)  # 每次输出顺序可能不同
#     int_set = {5, 2, 8}
#     print(int_set)  # 始终输出{2, 5, 8}（按整数大小排序）

# 3. 核心特性：唯一性（自动去重）
#   - 功能：集合中不会有重复元素，添加重复元素时会自动忽略
#   - 示例：
#     drops = {"骨头", "箭", "骨头", "腐肉"}
#     print(drops)  # 输出{'骨头', '箭', '腐肉'}（自动去除重复的'骨头'）

# 4. 常用操作：添加元素
#   - add(元素)：
#     - 功能：向集合添加单个元素（元素可以是不可迭代对象，如字符串、数字）
#     - 特点：若元素已存在，不做任何操作
#     - 示例：
#       blocks = {"石头", "木头"}
#       blocks.add("玻璃")  # 集合变为{"石头", "木头", "玻璃"}
#       blocks.add("石头")  # 集合不变（元素已存在）
#   - update(可迭代对象)：
#     - 功能：将可迭代对象（如列表、元组、字符串）中的元素逐个添加到集合
#     - 特点：输入必须是可迭代对象，会自动拆分元素并去重
#     - 示例：
#       tools = {"木镐", "石斧"}
#       tools.update(["铁剑", "木镐", "金锄"])  # 拆分列表元素添加
#       print(tools)  # 输出{"木镐", "石斧", "铁剑", "金锄"}（去重'木镐'）

# 5. 常用操作：删除元素
#   - remove(元素)：
#     - 功能：删除集合中指定元素
#     - 特点：若元素不存在，会报错
#     - 示例：
#       mobs = {"僵尸", "骷髅", "苦力怕"}
#       mobs.remove("骷髅")  # 集合变为{"僵尸", "苦力怕"}
#       mobs.remove("末影人")  # 报错（元素不存在）
#   - pop()：
#     - 功能：删除集合中按hash排序的第一个元素（纯整数集合删除最小元素）
#     - 特点：无参数，返回被删除的元素
#     - 示例：
#       items = {3, "苹果", "面包"}
#       removed = items.pop()  # 不确定删除哪个（因无序性）
#       print(removed)  # 可能输出3、"苹果"或"面包"
#   - discard(元素)：
#     - 功能：删除集合中指定元素
#     - 特点：若元素不存在，不做任何操作（不报错）
#     - 示例：
#       potions = {"速度", "力量", "跳跃"}
#       potions.discard("力量")  # 集合变为{"速度", "跳跃"}
#       potions.discard("隐身")  # 集合不变（无操作）

# 6. 集合运算：交集与并集
#   - 交集（&）：返回两个集合中**共同存在**的元素组成的新集合
#     - 示例：
#       s1 = {"煤矿", "铁矿", "钻石矿"}
#       s2 = {"铁矿", "金矿", "钻石矿"}
#       print(s1 & s2)  # 输出{"铁矿", "钻石矿"}（两集合共有的元素）
#   - 并集（|）：返回两个集合中**所有元素**（去重后）组成的新集合
#     - 示例：
#       s1 = {"小麦", "胡萝卜"}
#       s2 = {"胡萝卜", "马铃薯", "甜菜根"}
#       print(s1 | s2)  # 输出{"小麦", "胡萝卜", "马铃薯", "甜菜根"}


# 三、《我的世界》主题练习题


# （一）字典进阶操作练习题
# 1. len()应用
#   字典player = {"name": "Steve", "health": 20, "hunger": 20, "level": 5}，
#   计算该字典包含多少个键值对？
player = {"name": "Steve", "health": 20, "hunger": 20, "level": 5}
print("字典包含键值对数量：", len(player)) #输出4
# 2. keys()遍历
#   字典biomes = {"平原": "草方块", "沙漠": "沙块", "雪地": "雪块"}，
#   使用for循环遍历并打印所有生物群系的名称（即键）。
biomes = {"平原": "草方块", "沙漠": "沙块", "雪地": "雪块"}
for key in biomes.keys():
    print("生物群系的名称：", key) #输出生物群系的名称
# 3. values()统计
#   字典chest = {"面包": 6, "牛排": 3, "苹果": 10, "胡萝卜": 8}，
#   计算所有物品的总数量（即所有值的和）。
chest = {"面包": 6, "牛排": 3, "苹果": 10, "胡萝卜": 8}
num = 0
for i in chest.values():
    num += i
print("所有物品的总数量：", num) #所有物品的总数量
# 4. items()应用
#   字典mobs = {"僵尸": 50, "骷髅": 40, "苦力怕": 60}（键为生物名，值为生命值），
#   遍历所有键值对，打印“[生物名]的生命值是[值]”。
mobs = {"僵尸": 50, "骷髅": 40, "苦力怕": 60}
for a1, a2 in mobs.items():
    print(f"[{a1}]的生命值是[{a2}]")
# （二）集合练习题
# 1. 基本创建
#   （1）创建一个包含“橡木”、“桦木”、“松木”的集合woods；
#   （2）创建一个空集合empty_set。
woods = {"橡木", "桦木", "桦木"}
empty_set = set()
# 2. 无序性验证
#   集合drops = {"线", "羽毛", "火药", 5}，连续打印两次该集合，观察输出顺序是否相同？
drops = {"线", "羽毛", "火药", 5}
print(drops)
print(drops) #运行两次结果不同，每一次输出是相同的
# 3. 唯一性应用
#   玩家背包中重复收集了物品：["铁锭", "铁锭", "金锭", "铁锭", "金锭"]，
#   用集合处理后，剩余哪些不重复的物品？
# "铁锭",  "金锭",
# 4. 添加元素
#   （1）集合tools = {"木斧", "石镐"}，用add()添加“铁剑”；
#   （2）用update()添加列表["木镐", "金锄", "铁剑"]，最终集合包含哪些元素？
tools = {"木斧", "石镐"}
tools.add("铁剑")
print(tools)
tools.update(["木镐", "金锄", "铁剑"])
print(tools) #{'木镐', '铁剑', '木斧', '金锄', '石镐'}
# 5. 删除元素
#   集合blocks = {"石头", "玻璃", "木头", "沙子"}，
#   （1）用remove()删除“玻璃”；
#   （2）用discard()删除“泥土”；
#   （3）用pop()删除一个元素，集合最终可能剩余哪些元素？
blocks = {"石头", "玻璃", "木头", "沙子"}
print(blocks)
blocks.remove("玻璃")
print(blocks)
blocks.discard("泥土")
print(blocks) #不存在泥土，不做任何操作
blocks.pop()
print(blocks) #随机删除，剩下'沙子', '石头', '木头'的两个
# 6. 交集与并集
#   （1）集合s1 = {"小麦种子", "胡萝卜种子", "南瓜种子"}，
#        集合s2 = {"胡萝卜种子", "甜菜种子", "西瓜种子"}，
#        求两集合的交集（共同的种子）；
#   （2）求两集合的并集（所有种子）。
s1 = {"小麦种子", "胡萝卜种子", "南瓜种子"}
s2 = {"胡萝卜种子", "甜菜种子", "西瓜种子"}
print("共同的种子：", s1 & s2)
print("所有种子：", s1 | s2)