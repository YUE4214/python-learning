# 一、类型转换
# 1.1 int(x):将x转换成整数。只能转换由纯数字组成的字符串
# 浮点型转换为整数直接去掉小数点及后面的数值，只保留整数。
# 如果字符串中包含数字和正负号（注意区分开头的正负号以及结尾的加号减号）以外的字符，那么int就会报错
# a = "112"
# print(a,type(a))
# b = int(a)
# print(b,type(b))
# c = -1.22
# print(int(c))
# d = "str"
# print(int(d))#报错
# a = int(input("请输入当前年份："))
# print(a,type(a))

# 1.2 float(x):将x转换成浮点型，自动添加一位小数。
# 如果字符串串包含数字、正负号、小数点之外的字符，则不支持该转换
# a = 1
# print(float(a)) #输出1.0

# 1.3 str(x):将x转换为字符串类型，任何类型都可以转换为字符串类型
# 浮点型转换为字符串类型会去除末位为零的小数部分
# a = 1.000
# print(str(a)) #1.0

# 1.4 eval(str):用来计算字符串中有效的Python表达式并返回一个对象
# eval可以实现list列表、dict字典、tuple元组和str字符串之间的转换
# eval非常强大，但是不够安全，容易被恶意修改数据
# print(10 + 10) #20
# print("10" + "10") #1010
# print("10 + 10") #10 + 10
# print(eval("10 + 10")) #20 执行运算并且返回运算的值
# print(eval("10" + "10")) #1010
#str->list
# st1 = "[[1, 2], [3, 4], [5, 6]]"
# print(st1,type(st1))
# li = eval(st1) #str->list
# print(li,type(li))

# 1.5 list(x):将可迭代对象x转换为列表，x的类型主要是str字符串、tuple元组、dict字典、set集合
# 字典转换为列表，取键名作为列表的值
# 集合转换为列表会先自动去重，再进行转换，同样是无序的
# str -> list
# print(list("acdfs"))
# print(list(12346)) #报错
# tuple -> list
# print(list((1, 21, 3, 4)))
# dict -> list
# print(list({"年份": 2015, "月份": 8})) #['年份', '月份']
# set -> list
# print(list({"a", "a", "b", "c"}))
# 二、深浅拷贝
# 2.1 赋值：会随着原对象一起变化
# li = [1, 2, 3, 4]
# print(li)
# li2 = li
# print(li2)
# li.append(5) #这里的增加元素相当于在li的地址直接进行操作
# print(li)
# print(li2)
# 赋值：等于完全共享资源，一个值改变会完全被另一个值共享
# 赋值的内存地址是一样的
# 2.2浅拷贝：会创建新的对象，拷贝第一层的数据，嵌套层会指向原来的内存地址。
# 外层的内存地址不同，内层的内存地址相同
# 优点：拷贝速度快，占用空间少，拷贝效率高，数据半共享。
# import copy
# li = [1, 2, 3, 4, [5, 6]]
# li2 = copy.copy(li)
# li.append(7) #这里增加元素，li2的没有跟随添加
# li[4].append(7) #这里内层嵌套，li2的元素和li相同
# print(li)
# print(id(li))#id查看内存地址
# print(li2)
# print(id(li2))#li2和li的内存地址不同，说明不是一个对象
# 2.3深拷贝：数据完全不共享。
# 外层的对象和内部的元素全都拷贝一遍。
# 深拷贝只影响自己本身，跟原本的对象没有关联。
# import copy
# li = [1, 2, 3, 4, [5, 6]]
# li2 = copy.deepcopy(li)
# li.append(7) #这里增加元素，li2的没有跟随添加
# li[4].append(7) #这里内层嵌套，li2的没有跟随添加
# print(li)
# print(id(li))#id查看内存地址
# print(id(li[4]))
# print(li2)
# print(id(li2))#li2和li的内存地址不同，说明不是一个对象
# print(id(li2[4]))#li2和li的内存元素的内存地址不同，说明不是一个对象
# 三、可变对象
# 3.1存储空间保存的数据允许修改，这种类型就是可变类型。修改后，内存地址不会发生改变。
# 比如列表list 字典dict 集合set
# a = {"1", "a", "池"}
# print(id(a), a)
# a.add("非")
# print(id(a), a)
# 四、不可变对象
# 4.1存储空间保存的数据不允许修改，这种类型就是可变类型。重新复制后，生成新的值，内存地址同时发生变化。深浅拷贝只针对可变对象，不可变对象没有这个说法。
# 比如数值类型：int bool float complex 字符串str 元组tuple
# a = ("1", "a", "池")
# b = 1
# print(id(a), a)
# print(id(b), b)
# a = {"2", "a", "池"}
# b = 2
# print(id(a), a)
# print(id(b), b)

###豆包总结
# 一、类型转换知识点总结
# 1.1 int(x)：将x转换为整数
# - 支持转换：纯数字字符串（仅含数字和开头的正负号，如"123"、"-45"）、浮点型（直接截断小数部分）、布尔值（int(True)=1，int(False)=0）
# - 不支持：含非数字字符的字符串（如"12a"、"34-"，后者负号在结尾）
# - 示例：int("123")=123；int(45.6)=45；int(False)=0


# 1.2 float(x)：将x转换为浮点型（自动保留小数位）
# - 支持转换：纯数字/带小数点的字符串（如"123"、"45.6"、"-78.9"）、整数、布尔值（float(True)=1.0，float(False)=0.0）
# - 不支持：含多个小数点或非数字字符的字符串（如"12.3.4"、"56a.7"）
# - 示例：float("12")=12.0；float(34)=34.0；float("-5.6")=-5.6


# 1.3 str(x)：将x转换为字符串（所有类型均可转换）
# - 转换后保留原格式特征：如列表转字符串保留"[]"，字典保留"{}"
# - 特殊：浮点型末位0会简化（如str(1.000)="1.0"）；布尔值转字符串为"True"/"False"
# - 示例：str([1,2])="[1, 2]"；str({"a":1})="{'a': 1}"；str(3.14)="3.14"


# 1.4 eval(str)：计算字符串中的Python表达式并返回结果
# - 支持转换：字符串与列表、字典、元组等的互转（如eval("[1,2]")得到列表）
# - 功能：可直接执行字符串中的运算（如eval("10+20")=30）
# - 风险：安全性低，若输入恶意代码（如删除文件指令）会被执行，慎用
# - 示例：eval("(1,2,3)")=(1,2,3)；eval("{'x':10}")={'x':10}


# 1.5 list(x)：将可迭代对象x转换为列表
# - 支持的x类型及转换规则：
#   - 字符串：每个字符作为元素（如list("abc")=["a","b","c"]）
#   - 元组：直接转为列表（如list((1,2))=[1,2]）
#   - 字典：仅取键作为元素（如list({"a":1})=["a"]）
#   - 集合：去重后无序转换（如list({"a","a","b"})=["a","b"]（顺序不确定））
#   - range对象：转为连续整数列表（如list(range(3))=[0,1,2]）
# - 不支持：非可迭代对象（如list(123)会报错）


# 二、深浅拷贝与赋值知识点总结
# 2.1 赋值（=）
# - 本质：新变量与原变量指向同一内存地址，共享所有数据
# - 特征：原对象修改时，新变量会同步变化（无论层级）
# - 示例：li = [1,2]；li2=li；li.append(3) → li2也会变为[1,2,3]


# 2.2 浅拷贝（copy.copy()）
# - 本质：创建新对象，仅拷贝外层数据；嵌套的可变对象仍与原对象共享内存
# - 特征：
#   - 外层修改：新对象不受影响（如原列表添加元素，拷贝列表不变）
#   - 嵌套层修改：新对象会同步变化（如原列表的子列表添加元素，拷贝列表的子列表也变）
# - 其他实现方式：列表切片li[:]、字典d.copy()、集合s.copy()
# - 示例：li = [1, [2,3]]；li2=copy.copy(li)；li.append(4) → li2不变；li[1].append(5) → li2[1]变为[2,3,5]


# 2.3 深拷贝（copy.deepcopy()）
# - 本质：创建全新对象，外层及所有嵌套的可变对象均独立拷贝（完全不共享内存）
# - 特征：原对象任何层级修改，新对象都不受影响
# - 适用场景：需要完全独立的数据副本时使用（效率低于浅拷贝）
# - 示例：li = [1, [2,3]]；li2=copy.deepcopy(li)；li.append(4) → li2不变；li[1].append(5) → li2[1]仍为[2,3]


# 三、可变对象与不可变对象知识点总结
# 3.1 可变对象
# - 定义：存储空间的数据可修改，修改后内存地址不变
# - 类型：列表（list）、字典（dict）、集合（set）
# - 修改方式：通过内置方法修改（如列表append()、字典添加键值对、集合add()）
# - 示例：s = {"木头", "石头"}；s.add("铁矿") → 地址不变，s变为{"木头", "石头", "铁矿"}


# 3.2 不可变对象
# - 定义：存储空间的数据不可修改，修改需重新赋值，生成新对象（地址改变）
# - 类型：int、bool、float、complex、str（字符串）、tuple（元组）
# - 特殊：元组若包含可变对象（如列表），可修改内部可变对象（元组自身地址不变）
# - 示例：s = "Steve"；s = "Alex" → 新地址；t = (1, [2,3])；t[1].append(4) → t地址不变，t变为(1, [2,3,4])


# 四、《我的世界》主题练习题
# 类型转换练习题
# 1. 玩家输入自己的游戏时长（字符串形式，如"180"分钟），用int()转换为整数并打印结果
# play_time = input("输入游玩时间：")
# print(int(play_time))
# 2. 我的世界中"沙子"方块的硬度是0.5，用float()将整数0转换为与之相同的浮点型硬度值并打印
# print(float(0))
# 3. 将列表["钻石剑", "铁甲", "面包"]用str()转换为字符串，查看转换后的格式
# li3 = ["钻石剑", "铁甲", "面包"]
# st3 = str(li3)
# print(type(st3),st3)
# 4. 字符串"{'木头': 64, '石头': 32}"代表玩家背包的物品数量，用eval()转换为字典并打印
# st4 = "{'木头': 64, '石头': 32}"
# dic4 = eval(st4)
# print(dic4)
# 5. 将字符串"minecraft"（游戏名）用list()转换为列表，观察得到的元素
# str5 = "minecraft"
# list5 = list(str5)
# print(list5)
# 深浅拷贝与赋值练习题
# 1. 玩家的初始物品列表为li = ["橡木", "圆石", "煤炭"]，将li赋值给li2后，给li添加"铁矿"，打印li和li2，观察li2是否变化
# li = ["橡木", "圆石", "煤炭"]
# li2 = li
# li.append("铁矿")
# print(li)
# print(li2)
# 2. 用copy.copy()浅拷贝列表li = ["羊毛", ["木斧", "木镐"]]得到li2，执行操作：li.append("金锭")、li[1].append("木剑")，打印li和li2，观察变化
# import copy
# li = ["羊毛", ["木斧", "木镐"]]
# li2 = copy.copy(li)
# li.append("金锭")
# li[1].append("木剑")
# print(li)
# print(li2)
# 3. 用copy.deepcopy()深拷贝列表li = ["玻璃", ["铁剑", "铁镐"]]得到li2，执行操作：li.append("钻石")、li[1].append("铁斧")，打印li和li2，观察变化
# import copy
# li = ["玻璃", ["铁剑", "铁镐"]]
# li2 = copy.deepcopy(li)
# li.append("钻石")
# li[1].append("铁斧")
# print(li)
# print(li2)
# 可变与不可变对象练习题
# 1. 玩家的背包是列表["牛肉", "胡萝卜", "水"]，使用append()添加"苹果"后，用id()查看背包的内存地址是否变化
# li1 = ["牛肉", "胡萝卜", "水"]
# print(id(li1))
# li1.append("苹果")
# print(id(li1))
# 2. 玩家的游戏ID是字符串"Herobrine"，修改为"Notch"后，用id()查看ID的内存地址是否变化
# st1 = "Herobrine"
# print(id(st1))
# st1 = "Notch"
# print(id(st1))
# 3. 一个元组t = ("草方块", [1, 2, 3])（数字代表数量），给t[1]添加4后，用id()查看元组t的内存地址是否变化
# t = ("草方块", [1, 2, 3])
# print(id(t))
# t[1].append(4)
# print(id(t))
