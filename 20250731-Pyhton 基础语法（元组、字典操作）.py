###2025年7月31日学习笔记：
# 1.元组
# 1.1元组tuple
# 格式：元组名 = (元素1,元素2,元素3,,,,)
# 元组内部元素的类型可以不同，元素之间使用","进行分隔。
# 空元组格式：a = ()
# 如果元组中只有一个元素，需要在末尾添加","，否则不是元组类型，而是数据原本的类型。a = (1,)
# a = (1,2,"a","b","汉字")
# print(a)
# print(type(a))
# 1.2元组和列表的区别
# （1）如果元组中只有一个元素，需要在末尾添加","，否则不是元组类型，而是数据原本的类型。列表则不需要。
# （2）元组仅支持查询操作，不支持增删改操作。
# （3）元组的元素下标和列表规则相同。
# a = (1,2,"a","b","汉字")
# print(a[4])
# print(a.index(2))
# print(a.count(2))
# print(len(a)) #长度
# print(a[1:3]) #切片
# 1.3元组的应用场景
# （1）函数的参数和返回值。
# （2）格式化输出的小括号本质上也是元组。
# （3）数据不可以被修改的时候，保护数据安全。
# name = input("姓名：")
# age = int(input("年龄："))
# tup = (name,age)
# print("姓名：%s；年龄：%d" % (name,age)) #(name,age)就是元组
# print("姓名：%s；年龄：%d" % tup) #tup就是元组

# 2.字典
# 2.1字典
# 格式：字典名 = {键1:值1,键2:值2,,,}
# 键1，键2具有唯一性，如果两者相同，会被后者覆盖。
# dic = {"name":"yue","age":49}
# print(dic)
# print(type(dic))
# dic2 = {"name":"yue","name":"YUE"}
# print(dic2)
# 2.2字典常见操作
# （1）查看：字典名[键名]。不可以像列表和元组一样使用下标访问，字典中没有下标。如果键名不存在，则报错。
# （2）查看：字典名.get(键名)。如果键名不存在，未设置则返回None。
# （3）修改：字典名[已存在的键名] = 新的值。如果键名不存在，则新增这个键名到字典中，见（4）。
# （4）增加元素：字典名[不存在的键名] = 值。默认在后排添加。
# （5）删除字典：del 字典名。删除整个字典，删除后该字典不在存在。
# （6）删除指定键值对：del 字典名[已存在的键名]。如果键名不存在，则报错。
# （7）清除字典：字典名.clear()。清除整个字典，但保留这个字典
# （8）删除指定键值对：字典名.pop(已存在的键名)。如果键名不存在，则报错。
# （9）字典名.popitem()。默认删除最后一个键值。
# dic = {"name":"yue","age":49}
# print(dic["name"])
# print(dic.get("name1","不存在")) #如果键名不存在，则返回"不存在"。
# dic["age"] = 1
# dic["tel"] = 654
# print(dic)
# # del dic #删除字典
# # del dic["name1"] #如果键名不存在，则报错。
# del dic["name"]
# dic.pop("name")
# print(dic)

###豆包总结和试题
# 元组与字典知识点总结（结合《我的世界》）


# 一、元组（tuple）
# 1. 基本定义与格式
#   - 格式：元组名 = (元素1, 元素2, ...)，元素类型可混合（数字、字符串等）
#   - 特殊形式：
#     - 空元组：a = ()
#     - 单元素元组：必须加逗号（如(元素,)），否则为元素本身类型（如(5)是int，(5,)才是tuple）

# 2. 与列表的核心区别
#   - 可修改性：元组仅支持查询（不可增删改）；列表支持增删改查
#   - 单元素处理：元组单元素需加逗号，列表无需（如[5]直接是列表）
#   - 下标规则：与列表一致（从0开始，支持负数下标，如元组[-1]取最后一个元素）

# 3. 常用查询操作
#   - 下标访问：元组名[下标]（如blocks[2]取第3个元素）
#   - index(值)：返回首个匹配值的下标（无匹配值报错）
#   - count(值)：返回值出现的次数
#   - len(元组名)：返回元素总数
#   - 切片：元组名[start:end:step]（如mobs[1:4]取第2到第4个元素，含头不含尾）

# 4. 扩展特性
#   - 元素指向不可变：元组本身不可修改元素指向，但元素为可变类型（如列表）时，内部可改（如(1, [2,3])中列表可改）
#   - 拼接与重复：t1 + t2合并元组；t * n重复n次（如(1,2)*3 → (1,2,1,2,1,2)）
#   - 遍历：for 元素 in 元组名 循环访问所有元素

# 5. 应用场景
#   - 存储不可修改数据（如固定坐标、物品配方）
#   - 函数参数/返回值（如返回多个结果）
#   - 格式化输出（如print("x:%d,y:%d" % (x,y))中(x,y)是元组）


# 二、字典（dict）
# 1. 基本定义与格式
#   - 格式：字典名 = {键1:值1, 键2:值2, ...}，键值对用逗号分隔
#   - 键的特性：
#     - 唯一性：键重复时，后键覆盖前键（如{"a":1, "a":2}最终"a"为2）
#     - 不可变类型：键必须是不可变类型（int、str、tuple等），不能是列表
#   - 值的特性：可任意类型（数字、字符串、列表、元组等）
#   - 创建方式：除字面量外，可用dict(键1=值1, 键2=值2)（如dict(name="Steve", age=20)）

# 2. 常用操作
#   - 查看值：
#     - 字典名[键]：直接获取值（键不存在报错）
#     - 字典名.get(键, 默认值)：键存在返回值，不存在返回默认值（默认None，如dict.get("k", 0)）
#   - 修改值：字典名[已存在键] = 新值（更新对应值）
#   - 新增键值对：字典名[新键] = 值（自动添加到字典）
#   - 删除操作：
#     - del 字典名：删除整个字典（删除后不存在）
#     - del 字典名[键]：删除指定键值对（键不存在报错）
#     - 字典名.clear()：清空字典（保留空字典）
#     - 字典名.pop(键)：删除并返回指定键的值（键不存在报错）
#     - 字典名.popitem()：删除并返回最后一个键值对（Python 3.7+按插入顺序）

# 3. 扩展操作
#   - 遍历：
#     - for 键 in 字典名.keys()：遍历所有键
#     - for 值 in 字典名.values()：遍历所有值
#     - for 键, 值 in 字典名.items()：遍历所有键值对
#   - 复制：字典名.copy()（浅复制，仅复制表面层）


# 三、《我的世界》主题练习题


# （一）元组练习题
# 1. 基础创建
#   玩家的家坐标为x=100、y=75、z=200，用元组home_pos存储该坐标；
#   创建仅包含“末影珍珠”的单元素元组ender_pearl。
#   答案示例：
#   home_pos = (100, 75, 200)
#   ender_pearl = ("末影珍珠",)
# home_pos = (100, 75, 200)
# ender_pearl = ("末影珍珠",)
# print(home_pos)
# print(ender_pearl)
# print(type(home_pos))
# print(type(home_pos))
# 2. 下标与len
#   元组ores = ("煤矿", "铁矿", "金矿", "钻石矿")，用下标获取“铁矿”，并计算元素总数。
#   答案示例：
#   铁矿 = ores[1]
#   总数 = len(ores)  # 结果为4
ores = ("煤矿", "铁矿", "金矿", "钻石矿")
# print(ores[1])
# print(len(ores))
# 3. index与count
#   元组drops = ("骨头", "箭", "骨头", "腐肉", "箭")是骷髅掉落物，
#   查找“腐肉”的下标，并统计“骨头”出现的次数。
#   答案示例：
#   腐肉下标 = drops.index("腐肉")  # 结果为3
#   骨头次数 = drops.count("骨头")  # 结果为2
# drops = ("骨头", "箭", "骨头", "腐肉", "箭")
# print(drops.index("腐肉"))
# print(drops.count("骨头"))
# 4. 切片操作
#   元组tools = ("木镐", "石镐", "铁镐", "金镐", "钻石镐")，
#   用切片获取从“石镐”到“金镐”的元素（包含两者）。
#   答案示例：
#   结果 = tools[1:4]  # 输出('石镐', '铁镐', '金镐')
# tools = ("木镐", "石镐", "铁镐", "金镐", "钻石镐")
# print(tools[1:4])
# 5. 不可修改特性
#   元组bosses = ("末影龙", "凋灵")，尝试将第1个元素改为“卫道士”，会发生什么？
#   （选择：A. 成功修改 B. 报错）
#   答案：B

# 6. 拼接与重复
#   元组t1 = ("橡木台阶", "桦木台阶")，t2 = ("松木台阶", "丛林木台阶")，
#   将两者合并为all_steps；将("玻璃",)重复4次，得到新元组。
#   答案示例：
#   all_steps = t1 + t2  # 结果('橡木台阶', '桦木台阶', '松木台阶', '丛林木台阶')
#   玻璃元组 = ("玻璃",) * 4  # 结果('玻璃', '玻璃', '玻璃', '玻璃')
# t1 = ("橡木台阶", "桦木台阶")
# t2 = ("松木台阶", "丛林木台阶")
# all_steps = t1 + t2
# grass_steps = ("玻璃",) * 4
# print(all_steps)
# print(grass_steps)
# （二）字典练习题
# 1. 基础创建
#   用字典creeper存储苦力怕的信息：
#   键“name”对应“苦力怕”，“health”对应20，“damage”对应40（爆炸伤害）。
#   答案示例：
#   creeper = {"name": "苦力怕", "health": 20, "damage": 40}
# creeper = {"name": "苦力怕", "health": "20", "damage": "40"}
# print(creeper)
# print(type(creeper))
# 2. 键的唯一性
#   字典block = {"id":1, "name":"石头", "id":3, "name":"圆石"}，
#   最终“id”和“name”的值分别是什么？
#   答案：id=3；name=圆石

# 3. 查看值
#   字典chest = {"面包":6, "牛排":3, "苹果":10}，
#   用[键]获取“牛排”的数量；用get获取“钻石”的数量，默认返回0。
#   答案示例：
#   牛排数量 = chest["牛排"]  # 结果为3
#   钻石数量 = chest.get("钻石", 0)  # 结果为0
# chest = {"面包": 6, "牛排": 3, "苹果": 10}
# print(chest["牛排"])
# print(chest.get("钻石"))
# 4. 修改与新增
#   字典villager = {"职业": "铁匠", "等级": 1}，
#   将“等级”改为3；新增“交易物品”键，值为“铁剑”。
#   答案示例：
#   villager["等级"] = 3
#   villager["交易物品"] = "铁剑"
#   # 此时villager为{"职业": "铁匠", "等级": 3, "交易物品": "铁剑"}
# villager = {"职业": "铁匠", "等级": 1}
# villager["等级"] = 3
# villager["交易物品"] = "铁剑"
# print(villager)
# 5. 删除操作
#   （1）字典inventory = {"头盔":1, " leggings":1, "靴子":1}，用del删除“头盔”；
#   （2）用pop删除字典pet = {"类型": "狼", "名字": "旺财"}中的“类型”并返回值；
#   （3）用popitem删除字典potion = {"速度":1, "跳跃":2}的最后一个键值对；
#   （4）用clear清空字典chest（见题3）。
#   答案示例：
#   del inventory["头盔"]  # inventory变为{" leggings":1, "靴子":1}
#   类型值 = pet.pop("类型")  # 类型值为"狼"，pet变为{"名字": "旺财"}
#   last_item = potion.popitem()  # last_item为("跳跃", 2)，potion变为{"速度":1}
#   chest.clear()  # chest变为{}
# inventory = {"头盔":1, " leggings":1, "靴子":1}
# del inventory["头盔"]
# print(inventory)
# pet = {"类型": "狼", "名字": "旺财"}
# print(pet.pop("类型"))
# potion = {"速度":1, "跳跃":2}
# print(potion.popitem())
# chest = {"面包":6, "牛排":3, "苹果":10}
# print(chest.clear())
# 6. 键的类型
#   以下哪个字典能正确创建？为什么？
#   A. {(10, 20, 30): "宝箱"}  B. {[10, 20, 30]: "宝箱"}
#   答案：A（元组是不可变类型可作为键，列表是可变类型不可作为键）

# 7. 遍历操作
#   字典biomes = {"平原": "草方块", "沙漠": "沙块", "雪地": "雪块"}，
#   遍历并打印所有生物群系的名称（即键）。
#   答案示例：
#   for biome in biomes.keys():
#       print(biome)
#   # 输出：平原 沙漠 雪地（顺序可能因Python版本略有差异）
# biomes = {"平原": "草方块", "沙漠": "沙块", "雪地": "雪块"}
# for i in biomes.keys():
#     print(i)